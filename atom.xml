<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长林</title>
  
  <subtitle>学习前端的个人小博客</subtitle>
  <link href="atom.xml" rel="self"/>
  
  <link href="https://changlin2569.github.io/"/>
  <updated>2021-03-07T13:40:57.543Z</updated>
  <id>https://changlin2569.github.io/</id>
  
  <author>
    <name>changlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="2021/03/07/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>2021/03/07/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-03-07T13:40:57.542Z</published>
    <updated>2021-03-07T13:40:57.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行上下文栈和执行上下文"><a href="#执行上下文栈和执行上下文" class="headerlink" title="执行上下文栈和执行上下文"></a>执行上下文栈和执行上下文</h1><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><img src="https://user-gold-cdn.xitu.io/2019/5/20/16ad5133339a74a6?imageslim" alt="img" style="zoom:80%;" /><p><strong>上图的Stack就表示执行上下文栈，heap表示堆，我们定义的引用类型的值就存放在堆中，栈中存放的只是他们的引用；Queue中是消息队列，用于处理异步事件</strong></p><p>JavaScript中的代码不是一行一行的按顺序执行，而是根据不同的执行环境，创建不同的执行上下文，而这些不同的执行上下文就会被放在执行上下文栈中统一管理。</p><p>执行上下文分为三种：</p><ul><li>全局执行上下文：<strong>Global  context</strong></li><li>函数执行上下文：<strong>Function  context</strong></li><li>eval执行上下文：<strong>Eval  context</strong></li></ul><p>我们来看一段代码，理解执行上下文栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;Global scope&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;Function scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(scope);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&#x27;scope&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述JavaScript代码执行时，首先便会创建全局执行上下文<strong>Global  context</strong>，并且将全局执行上下文推入执行上下文栈，只有当所有代码都执行完毕的时候，全局上下文才会出栈。</p><p>我们用ECS来描述执行上下文栈(Execution context stack)</p><p>首先，全局执行上下文入栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECS = [</span><br><span class="line">    <span class="built_in">global</span> context,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后当代码执行到<code>foo(&#39;scope&#39;)</code>时，关于foo的函数执行上下文(foo context)被创建，并将其压入指向上下文栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECS = [</span><br><span class="line">    foo context,</span><br><span class="line"><span class="built_in">global</span> context,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后代码执行到bar()时，关于bar的执行上下文被创建，并压入执行上下文栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECS = [</span><br><span class="line">    bar context,</span><br><span class="line">    foo context,</span><br><span class="line"><span class="built_in">global</span> context,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>bar函数执行完时，他的执行上下文出栈，然后foo的执行上下文出栈，最后是全局执行上下文出栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ECS = [</span><br><span class="line">    bar context,</span><br><span class="line">    foo context,</span><br><span class="line"><span class="built_in">global</span> context,</span><br><span class="line">]</span><br><span class="line"><span class="comment">// bar函数执行完毕，出栈</span></span><br><span class="line">ECS = [</span><br><span class="line">    foo context,</span><br><span class="line"><span class="built_in">global</span> context,</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 随后foo函数执行完毕，出栈</span></span><br><span class="line">ECS = [</span><br><span class="line">    <span class="built_in">global</span> context,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="变量对象-VO-The-variable-object"><a href="#变量对象-VO-The-variable-object" class="headerlink" title="变量对象 (VO: The variable object)"></a>变量对象 (VO: The variable object)</h2><p>指向上下文中有三个重要的属性</p><ul><li><strong>变量对象</strong></li><li><strong>作用域链</strong></li><li><strong>this指向</strong></li></ul><h3 id="全局变量对象"><a href="#全局变量对象" class="headerlink" title="全局变量对象"></a>全局变量对象</h3><p>全局比那辆对象就是全局对象，通常在全局上下文中通过this来访问全局对象</p><p>**在浏览器中，全局对象为window；再node环境中，全局对象为global</p><h3 id="函数变量对象"><a href="#函数变量对象" class="headerlink" title="函数变量对象"></a>函数变量对象</h3><p>函数上下文的变量对象，我们暂且用活动对象（AO:  Active objects）来表示，因为只有再执行到这个函数的时候，函数的变量对象才会被创建，只有活动对象被创建为变量对象的时候，我们才能访问他的属性。</p><p>函数执行之前，会创建函数执行上下文，并初始化活动对象</p><ul><li>根据函数的arguments属性创建arguments对象</li><li>根据函数声明创建对应的属性，值为指针，指向堆中的函数，如果函数名存在，覆盖</li><li>根据变量声明创建属性，值为undefined；<strong>如果变量名已声明，则忽略该变量声明</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;Global scope&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;Function scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(scope);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&#x27;scope&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在foo函数执行之前，会创建函数执行上下文，并初始化活动对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ao = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;scope&quot;</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    s: <span class="string">&quot;scope&quot;</span>, <span class="comment">// 参数赋值</span></span><br><span class="line">    bar: Pointer to the <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span>   <span class="comment">// 变量声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在foo函数执行时，活动对象被激活为变量对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ao = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;scope&quot;</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    s: <span class="string">&quot;scope&quot;</span>, <span class="comment">// 参数赋值</span></span><br><span class="line">    bar: Pointer to the <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    scope: <span class="string">&#x27;Function scope&#x27;</span>   <span class="comment">// 变量赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p><strong>当代码在一个环境中执行时，会创建变量对象的一个作用域链。其用途是保证对执行环境有权访问的所有变量和函数的有序访问；作用域链的前端，始终是当前执行代码所在环境的变量对象</strong>搜索标识符时，始终从作用域链的最前端开始，逐级查找，知道找到，找不到会导致语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;Global scope&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;Function scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(scope);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&#x27;scope&#x27;</span>);</span><br></pre></td></tr></table></figure><p>首先在foo函数声明的时候，内部会创建scope的内部属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.[scope] = &#123;</span><br><span class="line">    globalcontext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在foo函数执行之前，创建执行上下文，并压入执行栈</p><ul><li>复制scope属性初始化作用域链</li><li>创建函数活动对象</li><li>将活动对象压入作用域链</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化作用域链</span></span><br><span class="line">foocontext = &#123;</span><br><span class="line">    scope: foo.[scope]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建活动对象</span></span><br><span class="line">foocontext = &#123;</span><br><span class="line">    scope: foo.[scope],</span><br><span class="line">    Ao = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;scope&quot;</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    s: <span class="string">&quot;scope&quot;</span>, <span class="comment">// 参数赋值</span></span><br><span class="line">    bar: Pointer to the <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span>   <span class="comment">// 变量声明</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将活动对象压入作用域链</span></span><br><span class="line"><span class="comment">// 创建活动对象</span></span><br><span class="line">foocontext = &#123;</span><br><span class="line">    scope: [</span><br><span class="line">        Ao,</span><br><span class="line">        foo.[scope],</span><br><span class="line">    ]</span><br><span class="line">    Ao = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;scope&quot;</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    s: <span class="string">&quot;scope&quot;</span>, <span class="comment">// 参数赋值</span></span><br><span class="line">    bar: Pointer to the <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span>   <span class="comment">// 变量声明</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数执行时，将活动对象激活为变量对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建活动对象</span></span><br><span class="line">foocontext = &#123;</span><br><span class="line">    scope: [</span><br><span class="line">        Ao,</span><br><span class="line">        foo.[scope],</span><br><span class="line">    ]</span><br><span class="line">    Ao = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;scope&quot;</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    s: <span class="string">&quot;scope&quot;</span>, <span class="comment">// 参数赋值</span></span><br><span class="line">    bar: Pointer to the <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    scope: <span class="string">&quot;&#x27;Function scope&quot;</span>   <span class="comment">// 变量赋值</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后bar函数创建[scope]属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar.[scope] = [</span><br><span class="line">    foocontext.VO,</span><br><span class="line">    globalcontext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><strong>这里的this分为全局执行上下文和函数执行上下文</strong></p><ul><li>全局执行上下文：<strong>this指向window或global</strong></li><li>函数执行上下文中：<strong>简单点讲，谁最后调用它，this就指向谁；如果在全局环境中被调用，则this指向window或global，严格模式下为undefined</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行上下文栈和执行上下文&quot;&gt;&lt;a href=&quot;#执行上下文栈和执行上下文&quot; class=&quot;headerlink&quot; title=&quot;执行上下文栈和执行上下文&quot;&gt;&lt;/a&gt;执行上下文栈和执行上下文&lt;/h1&gt;&lt;h2 id=&quot;执行上下文栈&quot;&gt;&lt;a href=&quot;#执行上下文栈&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="2020/12/13/this/"/>
    <id>2020/12/13/this/</id>
    <published>2020-12-13T13:57:56.165Z</published>
    <updated>2020-12-22T10:19:10.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><u>this是JavaScript中的关键字之一，它呗自动定义在所有函数的作用域中</u></p><h2 id="关于this的指向"><a href="#关于this的指向" class="headerlink" title="关于this的指向"></a>关于this的指向</h2><p>首先记住这些话，关于this的指向就有了大体的方向</p><p><strong>this既不指向函数自身，也不指向函数的词法作用域；它和函数的声明位置没有关系，只与调用位置有关，且this总是指向最后调用它的那个对象！</strong></p><p>我们来看这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) &#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.count);<span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>这是一段疾苦函数调用次数的demo，函数foo调用了三次，如果this指向的是函数自身的话，那么最后的 foo.count 就会输出3，但是输出的却是0。这表明foo中的this并不指向它自身。这也印证了前面所说的<strong>this不指向函数自身</strong></p><p><em>实际上，调用foo时，其中的this.count++其实为全局作用域创建了一个count变量，为什么我们下面说</em></p><p>再来看这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.bor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这段代码试图用this来连接bor和foo的此法作用域，但是失败了，因为<strong>this再任何情况下都不指向函数的词法作用域</strong></p><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用位置&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>通过上述代码可以看到，foo的调用位置在全局，但是在foo中调用了bor，又在bor中调用了baz，所以各个调用位置如下</p><ul><li>foo: 全局</li><li>bor: foo–&gt;bor ，调用位置为foo</li><li>baz: foo–&gt;bor–&gt;baz，调用位置为bor</li></ul><p>熟悉了绑定规则，来看一下绑定规则吧</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>当情形为独立函数调用时，应用的就是默认绑定规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以看到，调用函数foo时，其中的a输出的时全局变量中的1；这是因为在全局作用域下调用时，默认的调用对象是window。</p><p>如果是在严格模式下调用时，this优惠指向谁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    “use strict”</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span></span><br><span class="line">       <span class="comment">//at foo</span></span><br></pre></td></tr></table></figure><p>在严格模式下，this会指向undefined</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p><strong>当函数调用时拥有上下文对象，或者被某个对象拥有或包含</strong>此时会应用隐式绑定的原则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;；</span><br><span class="line">obj.foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以看到，输出为1，这是因为obj中的函数赋值操作，而且时obj调用了foo，所以foo中的this应用隐式绑定规则指向了obj。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    a = <span class="number">2</span>,</span><br><span class="line">    obj1: obj1,</span><br><span class="line">&#125;</span><br><span class="line">obj2.obj1.foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>由上述代码可以知道，this只和最后调用它的对象有关，最后调用foo的为obj1，所以输出1。这印证了开头所说，<strong>this永远指向最后调用他的对象</strong></p><h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>显示绑定主要运用call，apply，bind等方法强制改变this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj1: obj1,</span><br><span class="line">&#125;</span><br><span class="line">obj1.foo.call(obj2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，最后调用的对象是obj1，但是foo中的this缺指向obj2;这是因为我们运用了call方法显示将this绑定在obj2上。</p><p>除此之外，还有apply方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj1: obj1,</span><br><span class="line">&#125;</span><br><span class="line">obj1.foo.apply(obj2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>那么call 和 apply 有什么不同呢？他们在参数传递时略有不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a + x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">foo.apply(obj,[<span class="number">1</span>,<span class="number">2</span>]);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>可以看到，call和apply主要区别在于传递参数的不同，call和apply的第一个参数是要绑定的this对象；call的第二个参数是要接收的参数列表。但是apply是一个数组。</p><p>还有一种bind 方法也可以实现改变this绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn,obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(obj);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">foo = bind(foo,obj1);</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这创建了一个辅助函数用来修改this的指向，但是其中JavaScript中存在bind方法用来修改this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a + x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo = foo.bind(obj,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">foo();  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>与call和apply不同的是bind方法创建一个新的函数， 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</strong></p><p>座椅bind会新创建一个函数，我们必须手动去调用。</p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>当用new调用一个函数或者发生构造函数调用时，会发生四步</p><ol><li>创建一个全新的对象</li><li>实现对象的原型连接</li><li>将函数调用时的this绑定在这个新对象上</li><li>如果没有返回对象，则返回这个新创建的对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6中引入了箭头函数，箭头函数没有自己的this，只能通过作用域查找来确定自己的this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然调用setTimeout的是window，但是箭头函数的this还是指向obj，<strong>因为箭头函数的this是根据函数或者全局作用域来决定this，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this；而且箭头函数绑定的this无法修改</strong></p><p>上述代码的实现过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(that.a);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在foo中我们用that保存了this的值。</p><p>还有一种情况，<strong>如果箭头函数没有被非箭头函数包含，那么其中的this会指向window，在严格模式下，this为underfined</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;p&gt;&lt;u&gt;this是JavaScript中的关键字之一，它呗自动定义在所有函数的作用域中&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>post</title>
    <link href="2020/11/12/var%20let%20const%E5%8C%BA%E5%88%AB/"/>
    <id>2020/11/12/var%20let%20const%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-12T13:39:30.000Z</published>
    <updated>2020-12-22T10:19:25.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var let const的区别"></a>var let const的区别</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ul><li><p>var声明的变量会变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上述代码会输出undefined</p></li></ul><h6 id="因为var声明的变量会自动提升到代码顶部，称为变量提升，所以上述代码的工作原理为"><a href="#因为var声明的变量会自动提升到代码顶部，称为变量提升，所以上述代码的工作原理为" class="headerlink" title="因为var声明的变量会自动提升到代码顶部，称为变量提升，所以上述代码的工作原理为"></a>因为var声明的变量会自动提升到代码顶部，称为变量提升，所以上述代码的工作原理为</h6>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h6 id="只是提升了变量的声明，初始化操作发生在原位置"><a href="#只是提升了变量的声明，初始化操作发生在原位置" class="headerlink" title="只是提升了变量的声明，初始化操作发生在原位置"></a>只是提升了变量的声明，初始化操作发生在原位置</h6><ul><li><p>var声明的变量不具有块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>可以看到输出结果为1，输出了if代码块中的变量</p><h6 id="var声明的变量只具有函数作用域和全局作用域"><a href="#var声明的变量只具有函数作用域和全局作用域" class="headerlink" title="var声明的变量只具有函数作用域和全局作用域"></a>var声明的变量只具有函数作用域和全局作用域</h6></li><li><p>var可以重复声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>以上代码在非严格模式下不会报错</p></li></ul><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul><li>let声明的变量不会变量提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>上述代码会报错</p><h6 id="let不允许在变量声明之前使用这个变量，会触发暂时性死区"><a href="#let不允许在变量声明之前使用这个变量，会触发暂时性死区" class="headerlink" title="let不允许在变量声明之前使用这个变量，会触发暂时性死区"></a>let不允许在变量声明之前使用这个变量，会触发暂时性死区</h6><ul><li>let声明的变量具有块级作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>let在代码块中定义的变量，只允许在代码块中访问</p><ul><li>let不允许重复声明变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>这样做的目的是减少变量重复赋值造成不可预计的危险</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>const声明的变量只可读</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//error</span></span><br></pre></td></tr></table></figure><h6 id="const声明的变量不可以重新赋值，只可读，用于不用修改的变量"><a href="#const声明的变量不可以重新赋值，只可读，用于不用修改的变量" class="headerlink" title="const声明的变量不可以重新赋值，只可读，用于不用修改的变量"></a>const声明的变量不可以重新赋值，只可读，用于不用修改的变量</h6><h6 id="而且const声明变量的时候必须初始化这个变量！"><a href="#而且const声明变量的时候必须初始化这个变量！" class="headerlink" title="而且const声明变量的时候必须初始化这个变量！"></a>而且const声明变量的时候必须初始化这个变量！</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x;</span><br><span class="line"><span class="comment">//error</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;var-let-const的区别&quot;&gt;&lt;a href=&quot;#var-let-const的区别&quot; class=&quot;headerlink&quot; title=&quot;var let const的区别&quot;&gt;&lt;/a&gt;var let const的区别&lt;/h1&gt;&lt;h2 id=&quot;var&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
</feed>
